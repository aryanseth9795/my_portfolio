{"ast":null,"code":"/**\r\n * TODO: These methods can probably be combined somehow\r\n * Parse HTML tags & HTML Characters\r\n */\nexport default class HTMLParser {\n  /**\r\n   * Type HTML tags & HTML Characters\r\n   * @param {string} curString Current string\r\n   * @param {number} curStrPos Position in current string\r\n   * @param {Typed} self instance of Typed\r\n   * @returns {number} a new string position\r\n   * @private\r\n   */\n  typeHtmlChars(curString, curStrPos, self) {\n    if (self.contentType !== 'html') return curStrPos;\n    const curChar = curString.substring(curStrPos).charAt(0);\n\n    if (curChar === '<' || curChar === '&') {\n      let endTag = '';\n\n      if (curChar === '<') {\n        endTag = '>';\n      } else {\n        endTag = ';';\n      }\n\n      while (curString.substring(curStrPos + 1).charAt(0) !== endTag) {\n        curStrPos++;\n\n        if (curStrPos + 1 > curString.length) {\n          break;\n        }\n      }\n\n      curStrPos++;\n    }\n\n    return curStrPos;\n  }\n  /**\r\n   * Backspace HTML tags and HTML Characters\r\n   * @param {string} curString Current string\r\n   * @param {number} curStrPos Position in current string\r\n   * @param {Typed} self instance of Typed\r\n   * @returns {number} a new string position\r\n   * @private\r\n   */\n\n\n  backSpaceHtmlChars(curString, curStrPos, self) {\n    if (self.contentType !== 'html') return curStrPos;\n    const curChar = curString.substring(curStrPos).charAt(0);\n\n    if (curChar === '>' || curChar === ';') {\n      let endTag = '';\n\n      if (curChar === '>') {\n        endTag = '<';\n      } else {\n        endTag = '&';\n      }\n\n      while (curString.substring(curStrPos - 1).charAt(0) !== endTag) {\n        curStrPos--;\n\n        if (curStrPos < 0) {\n          break;\n        }\n      }\n\n      curStrPos--;\n    }\n\n    return curStrPos;\n  }\n\n}\nexport let htmlParser = new HTMLParser();","map":{"version":3,"names":["HTMLParser","typeHtmlChars","curString","curStrPos","self","contentType","curChar","substring","charAt","endTag","length","backSpaceHtmlChars","htmlParser"],"sources":["F:/Desktop/react/my/src/components/html-parser.js"],"sourcesContent":["/**\r\n * TODO: These methods can probably be combined somehow\r\n * Parse HTML tags & HTML Characters\r\n */\r\n\r\nexport default class HTMLParser {\r\n    /**\r\n     * Type HTML tags & HTML Characters\r\n     * @param {string} curString Current string\r\n     * @param {number} curStrPos Position in current string\r\n     * @param {Typed} self instance of Typed\r\n     * @returns {number} a new string position\r\n     * @private\r\n     */\r\n  \r\n    typeHtmlChars(curString, curStrPos, self) {\r\n      if (self.contentType !== 'html') return curStrPos;\r\n      const curChar = curString.substring(curStrPos).charAt(0);\r\n      if (curChar === '<' || curChar === '&') {\r\n        let endTag = '';\r\n        if (curChar === '<') {\r\n          endTag = '>';\r\n        } else {\r\n          endTag = ';';\r\n        }\r\n        while (curString.substring(curStrPos + 1).charAt(0) !== endTag) {\r\n          curStrPos++;\r\n          if (curStrPos + 1 > curString.length) {\r\n            break;\r\n          }\r\n        }\r\n        curStrPos++;\r\n      }\r\n      return curStrPos;\r\n    }\r\n  \r\n    /**\r\n     * Backspace HTML tags and HTML Characters\r\n     * @param {string} curString Current string\r\n     * @param {number} curStrPos Position in current string\r\n     * @param {Typed} self instance of Typed\r\n     * @returns {number} a new string position\r\n     * @private\r\n     */\r\n    backSpaceHtmlChars(curString, curStrPos, self) {\r\n      if (self.contentType !== 'html') return curStrPos;\r\n      const curChar = curString.substring(curStrPos).charAt(0);\r\n      if (curChar === '>' || curChar === ';') {\r\n        let endTag = '';\r\n        if (curChar === '>') {\r\n          endTag = '<';\r\n        } else {\r\n          endTag = '&';\r\n        }\r\n        while (curString.substring(curStrPos - 1).charAt(0) !== endTag) {\r\n          curStrPos--;\r\n          if (curStrPos < 0) {\r\n            break;\r\n          }\r\n        }\r\n        curStrPos--;\r\n      }\r\n      return curStrPos;\r\n    }\r\n  }\r\n  \r\n  export let htmlParser = new HTMLParser();"],"mappings":"AAAA;AACA;AACA;AACA;AAEA,eAAe,MAAMA,UAAN,CAAiB;EAC5B;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EAEIC,aAAa,CAACC,SAAD,EAAYC,SAAZ,EAAuBC,IAAvB,EAA6B;IACxC,IAAIA,IAAI,CAACC,WAAL,KAAqB,MAAzB,EAAiC,OAAOF,SAAP;IACjC,MAAMG,OAAO,GAAGJ,SAAS,CAACK,SAAV,CAAoBJ,SAApB,EAA+BK,MAA/B,CAAsC,CAAtC,CAAhB;;IACA,IAAIF,OAAO,KAAK,GAAZ,IAAmBA,OAAO,KAAK,GAAnC,EAAwC;MACtC,IAAIG,MAAM,GAAG,EAAb;;MACA,IAAIH,OAAO,KAAK,GAAhB,EAAqB;QACnBG,MAAM,GAAG,GAAT;MACD,CAFD,MAEO;QACLA,MAAM,GAAG,GAAT;MACD;;MACD,OAAOP,SAAS,CAACK,SAAV,CAAoBJ,SAAS,GAAG,CAAhC,EAAmCK,MAAnC,CAA0C,CAA1C,MAAiDC,MAAxD,EAAgE;QAC9DN,SAAS;;QACT,IAAIA,SAAS,GAAG,CAAZ,GAAgBD,SAAS,CAACQ,MAA9B,EAAsC;UACpC;QACD;MACF;;MACDP,SAAS;IACV;;IACD,OAAOA,SAAP;EACD;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIQ,kBAAkB,CAACT,SAAD,EAAYC,SAAZ,EAAuBC,IAAvB,EAA6B;IAC7C,IAAIA,IAAI,CAACC,WAAL,KAAqB,MAAzB,EAAiC,OAAOF,SAAP;IACjC,MAAMG,OAAO,GAAGJ,SAAS,CAACK,SAAV,CAAoBJ,SAApB,EAA+BK,MAA/B,CAAsC,CAAtC,CAAhB;;IACA,IAAIF,OAAO,KAAK,GAAZ,IAAmBA,OAAO,KAAK,GAAnC,EAAwC;MACtC,IAAIG,MAAM,GAAG,EAAb;;MACA,IAAIH,OAAO,KAAK,GAAhB,EAAqB;QACnBG,MAAM,GAAG,GAAT;MACD,CAFD,MAEO;QACLA,MAAM,GAAG,GAAT;MACD;;MACD,OAAOP,SAAS,CAACK,SAAV,CAAoBJ,SAAS,GAAG,CAAhC,EAAmCK,MAAnC,CAA0C,CAA1C,MAAiDC,MAAxD,EAAgE;QAC9DN,SAAS;;QACT,IAAIA,SAAS,GAAG,CAAhB,EAAmB;UACjB;QACD;MACF;;MACDA,SAAS;IACV;;IACD,OAAOA,SAAP;EACD;;AA1D2B;AA6D9B,OAAO,IAAIS,UAAU,GAAG,IAAIZ,UAAJ,EAAjB"},"metadata":{},"sourceType":"module"}