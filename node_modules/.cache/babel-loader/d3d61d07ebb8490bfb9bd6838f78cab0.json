{"ast":null,"code":"import { initializer } from './initializer.js';\nimport { htmlParser } from './html-parser.js';\n/**\r\n * Welcome to Typed.js!\r\n * @param {string} elementId HTML element ID _OR_ HTML element\r\n * @param {object} options options object\r\n * @returns {object} a new Typed object\r\n */\n\nexport default class Typed {\n  constructor(elementId, options) {\n    // Initialize it up\n    initializer.load(this, options, elementId); // All systems go!\n\n    this.begin();\n  }\n  /**\r\n   * Toggle start() and stop() of the Typed instance\r\n   * @public\r\n   */\n\n\n  toggle() {\n    this.pause.status ? this.start() : this.stop();\n  }\n  /**\r\n   * Stop typing / backspacing and enable cursor blinking\r\n   * @public\r\n   */\n\n\n  stop() {\n    if (this.typingComplete) return;\n    if (this.pause.status) return;\n    this.toggleBlinking(true);\n    this.pause.status = true;\n    this.options.onStop(this.arrayPos, this);\n  }\n  /**\r\n   * Start typing / backspacing after being stopped\r\n   * @public\r\n   */\n\n\n  start() {\n    if (this.typingComplete) return;\n    if (!this.pause.status) return;\n    this.pause.status = false;\n\n    if (this.pause.typewrite) {\n      this.typewrite(this.pause.curString, this.pause.curStrPos);\n    } else {\n      this.backspace(this.pause.curString, this.pause.curStrPos);\n    }\n\n    this.options.onStart(this.arrayPos, this);\n  }\n  /**\r\n   * Destroy this instance of Typed\r\n   * @public\r\n   */\n\n\n  destroy() {\n    this.reset(false);\n    this.options.onDestroy(this);\n  }\n  /**\r\n   * Reset Typed and optionally restarts\r\n   * @param {boolean} restart\r\n   * @public\r\n   */\n\n\n  reset() {\n    let restart = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    clearInterval(this.timeout);\n    this.replaceText('');\n\n    if (this.cursor && this.cursor.parentNode) {\n      this.cursor.parentNode.removeChild(this.cursor);\n      this.cursor = null;\n    }\n\n    this.strPos = 0;\n    this.arrayPos = 0;\n    this.curLoop = 0;\n\n    if (restart) {\n      this.insertCursor();\n      this.options.onReset(this);\n      this.begin();\n    }\n  }\n  /**\r\n   * Begins the typing animation\r\n   * @private\r\n   */\n\n\n  begin() {\n    this.options.onBegin(this);\n    this.typingComplete = false;\n    this.shuffleStringsIfNeeded(this);\n    this.insertCursor();\n    if (this.bindInputFocusEvents) this.bindFocusEvents();\n    this.timeout = setTimeout(() => {\n      // If the strPos is 0, we're starting from the beginning of a string\n      // else, we're starting with a previous string that needs to be backspaced first\n      if (this.strPos === 0) {\n        this.typewrite(this.strings[this.sequence[this.arrayPos]], this.strPos);\n      } else {\n        this.backspace(this.strings[this.sequence[this.arrayPos]], this.strPos);\n      }\n    }, this.startDelay);\n  }\n  /**\r\n   * Called for each character typed\r\n   * @param {string} curString the current string in the strings array\r\n   * @param {number} curStrPos the current position in the curString\r\n   * @private\r\n   */\n\n\n  typewrite(curString, curStrPos) {\n    if (this.fadeOut && this.el.classList.contains(this.fadeOutClass)) {\n      this.el.classList.remove(this.fadeOutClass);\n      if (this.cursor) this.cursor.classList.remove(this.fadeOutClass);\n    }\n\n    const humanize = this.humanizer(this.typeSpeed);\n    let numChars = 1;\n\n    if (this.pause.status === true) {\n      this.setPauseStatus(curString, curStrPos, true);\n      return;\n    } // contain typing function in a timeout humanize'd delay\n\n\n    this.timeout = setTimeout(() => {\n      // skip over any HTML chars\n      curStrPos = htmlParser.typeHtmlChars(curString, curStrPos, this);\n      let pauseTime = 0;\n      let substr = curString.substring(curStrPos); // check for an escape character before a pause value\n      // format: \\^\\d+ .. eg: ^1000 .. should be able to print the ^ too using ^^\n      // single ^ are removed from string\n\n      if (substr.charAt(0) === '^') {\n        if (/^\\^\\d+/.test(substr)) {\n          let skip = 1; // skip at least 1\n\n          substr = /\\d+/.exec(substr)[0];\n          skip += substr.length;\n          pauseTime = parseInt(substr);\n          this.temporaryPause = true;\n          this.options.onTypingPaused(this.arrayPos, this); // strip out the escape character and pause value so they're not printed\n\n          curString = curString.substring(0, curStrPos) + curString.substring(curStrPos + skip);\n          this.toggleBlinking(true);\n        }\n      } // check for skip characters formatted as\n      // \"this is a `string to print NOW` ...\"\n\n\n      if (substr.charAt(0) === '`') {\n        while (curString.substring(curStrPos + numChars).charAt(0) !== '`') {\n          numChars++;\n          if (curStrPos + numChars > curString.length) break;\n        } // strip out the escape characters and append all the string in between\n\n\n        const stringBeforeSkip = curString.substring(0, curStrPos);\n        const stringSkipped = curString.substring(stringBeforeSkip.length + 1, curStrPos + numChars);\n        const stringAfterSkip = curString.substring(curStrPos + numChars + 1);\n        curString = stringBeforeSkip + stringSkipped + stringAfterSkip;\n        numChars--;\n      } // timeout for any pause after a character\n\n\n      this.timeout = setTimeout(() => {\n        // Accounts for blinking while paused\n        this.toggleBlinking(false); // We're done with this sentence!\n\n        if (curStrPos >= curString.length) {\n          this.doneTyping(curString, curStrPos);\n        } else {\n          this.keepTyping(curString, curStrPos, numChars);\n        } // end of character pause\n\n\n        if (this.temporaryPause) {\n          this.temporaryPause = false;\n          this.options.onTypingResumed(this.arrayPos, this);\n        }\n      }, pauseTime); // humanized value for typing\n    }, humanize);\n  }\n  /**\r\n   * Continue to the next string & begin typing\r\n   * @param {string} curString the current string in the strings array\r\n   * @param {number} curStrPos the current position in the curString\r\n   * @private\r\n   */\n\n\n  keepTyping(curString, curStrPos, numChars) {\n    // call before functions if applicable\n    if (curStrPos === 0) {\n      this.toggleBlinking(false);\n      this.options.preStringTyped(this.arrayPos, this);\n    } // start typing each new char into existing string\n    // curString: arg, this.el.html: original text inside element\n\n\n    curStrPos += numChars;\n    const nextString = curString.substring(0, curStrPos);\n    this.replaceText(nextString); // loop the function\n\n    this.typewrite(curString, curStrPos);\n  }\n  /**\r\n   * We're done typing the current string\r\n   * @param {string} curString the current string in the strings array\r\n   * @param {number} curStrPos the current position in the curString\r\n   * @private\r\n   */\n\n\n  doneTyping(curString, curStrPos) {\n    // fires callback function\n    this.options.onStringTyped(this.arrayPos, this);\n    this.toggleBlinking(true); // is this the final string\n\n    if (this.arrayPos === this.strings.length - 1) {\n      // callback that occurs on the last typed string\n      this.complete(); // quit if we wont loop back\n\n      if (this.loop === false || this.curLoop === this.loopCount) {\n        return;\n      }\n    }\n\n    this.timeout = setTimeout(() => {\n      this.backspace(curString, curStrPos);\n    }, this.backDelay);\n  }\n  /**\r\n   * Backspaces 1 character at a time\r\n   * @param {string} curString the current string in the strings array\r\n   * @param {number} curStrPos the current position in the curString\r\n   * @private\r\n   */\n\n\n  backspace(curString, curStrPos) {\n    if (this.pause.status === true) {\n      this.setPauseStatus(curString, curStrPos, false);\n      return;\n    }\n\n    if (this.fadeOut) return this.initFadeOut();\n    this.toggleBlinking(false);\n    const humanize = this.humanizer(this.backSpeed);\n    this.timeout = setTimeout(() => {\n      curStrPos = htmlParser.backSpaceHtmlChars(curString, curStrPos, this); // replace text with base text + typed characters\n\n      const curStringAtPosition = curString.substring(0, curStrPos);\n      this.replaceText(curStringAtPosition); // if smartBack is enabled\n\n      if (this.smartBackspace) {\n        // the remaining part of the current string is equal of the same part of the new string\n        let nextString = this.strings[this.arrayPos + 1];\n\n        if (nextString && curStringAtPosition === nextString.substring(0, curStrPos)) {\n          this.stopNum = curStrPos;\n        } else {\n          this.stopNum = 0;\n        }\n      } // if the number (id of character in current string) is\n      // less than the stop number, keep going\n\n\n      if (curStrPos > this.stopNum) {\n        // subtract characters one by one\n        curStrPos--; // loop the function\n\n        this.backspace(curString, curStrPos);\n      } else if (curStrPos <= this.stopNum) {\n        // if the stop number has been reached, increase\n        // array position to next string\n        this.arrayPos++; // When looping, begin at the beginning after backspace complete\n\n        if (this.arrayPos === this.strings.length) {\n          this.arrayPos = 0;\n          this.options.onLastStringBackspaced();\n          this.shuffleStringsIfNeeded();\n          this.begin();\n        } else {\n          this.typewrite(this.strings[this.sequence[this.arrayPos]], curStrPos);\n        }\n      } // humanized value for typing\n\n    }, humanize);\n  }\n  /**\r\n   * Full animation is complete\r\n   * @private\r\n   */\n\n\n  complete() {\n    this.options.onComplete(this);\n\n    if (this.loop) {\n      this.curLoop++;\n    } else {\n      this.typingComplete = true;\n    }\n  }\n  /**\r\n   * Has the typing been stopped\r\n   * @param {string} curString the current string in the strings array\r\n   * @param {number} curStrPos the current position in the curString\r\n   * @param {boolean} isTyping\r\n   * @private\r\n   */\n\n\n  setPauseStatus(curString, curStrPos, isTyping) {\n    this.pause.typewrite = isTyping;\n    this.pause.curString = curString;\n    this.pause.curStrPos = curStrPos;\n  }\n  /**\r\n   * Toggle the blinking cursor\r\n   * @param {boolean} isBlinking\r\n   * @private\r\n   */\n\n\n  toggleBlinking(isBlinking) {\n    if (!this.cursor) return; // if in paused state, don't toggle blinking a 2nd time\n\n    if (this.pause.status) return;\n    if (this.cursorBlinking === isBlinking) return;\n    this.cursorBlinking = isBlinking;\n\n    if (isBlinking) {\n      this.cursor.classList.add('typed-cursor--blink');\n    } else {\n      this.cursor.classList.remove('typed-cursor--blink');\n    }\n  }\n  /**\r\n   * Speed in MS to type\r\n   * @param {number} speed\r\n   * @private\r\n   */\n\n\n  humanizer(speed) {\n    return Math.round(Math.random() * speed / 2) + speed;\n  }\n  /**\r\n   * Shuffle the sequence of the strings array\r\n   * @private\r\n   */\n\n\n  shuffleStringsIfNeeded() {\n    if (!this.shuffle) return;\n    this.sequence = this.sequence.sort(() => Math.random() - 0.5);\n  }\n  /**\r\n   * Adds a CSS class to fade out current string\r\n   * @private\r\n   */\n\n\n  initFadeOut() {\n    this.el.className += ` ${this.fadeOutClass}`;\n    if (this.cursor) this.cursor.className += ` ${this.fadeOutClass}`;\n    return setTimeout(() => {\n      this.arrayPos++;\n      this.replaceText(''); // Resets current string if end of loop reached\n\n      if (this.strings.length > this.arrayPos) {\n        this.typewrite(this.strings[this.sequence[this.arrayPos]], 0);\n      } else {\n        this.typewrite(this.strings[0], 0);\n        this.arrayPos = 0;\n      }\n    }, this.fadeOutDelay);\n  }\n  /**\r\n   * Replaces current text in the HTML element\r\n   * depending on element type\r\n   * @param {string} str\r\n   * @private\r\n   */\n\n\n  replaceText(str) {\n    if (this.attr) {\n      this.el.setAttribute(this.attr, str);\n    } else {\n      if (this.isInput) {\n        this.el.value = str;\n      } else if (this.contentType === 'html') {\n        this.el.innerHTML = str;\n      } else {\n        this.el.textContent = str;\n      }\n    }\n  }\n  /**\r\n   * If using input elements, bind focus in order to\r\n   * start and stop the animation\r\n   * @private\r\n   */\n\n\n  bindFocusEvents() {\n    if (!this.isInput) return;\n    this.el.addEventListener('focus', e => {\n      this.stop();\n    });\n    this.el.addEventListener('blur', e => {\n      if (this.el.value && this.el.value.length !== 0) {\n        return;\n      }\n\n      this.start();\n    });\n  }\n  /**\r\n   * On init, insert the cursor element\r\n   * @private\r\n   */\n\n\n  insertCursor() {\n    if (!this.showCursor) return;\n    if (this.cursor) return;\n    this.cursor = document.createElement('span');\n    this.cursor.className = 'typed-cursor';\n    this.cursor.setAttribute('aria-hidden', true);\n    this.cursor.innerHTML = this.cursorChar;\n    this.el.parentNode && this.el.parentNode.insertBefore(this.cursor, this.el.nextSibling);\n  }\n\n}","map":{"version":3,"names":["initializer","htmlParser","Typed","constructor","elementId","options","load","begin","toggle","pause","status","start","stop","typingComplete","toggleBlinking","onStop","arrayPos","typewrite","curString","curStrPos","backspace","onStart","destroy","reset","onDestroy","restart","clearInterval","timeout","replaceText","cursor","parentNode","removeChild","strPos","curLoop","insertCursor","onReset","onBegin","shuffleStringsIfNeeded","bindInputFocusEvents","bindFocusEvents","setTimeout","strings","sequence","startDelay","fadeOut","el","classList","contains","fadeOutClass","remove","humanize","humanizer","typeSpeed","numChars","setPauseStatus","typeHtmlChars","pauseTime","substr","substring","charAt","test","skip","exec","length","parseInt","temporaryPause","onTypingPaused","stringBeforeSkip","stringSkipped","stringAfterSkip","doneTyping","keepTyping","onTypingResumed","preStringTyped","nextString","onStringTyped","complete","loop","loopCount","backDelay","initFadeOut","backSpeed","backSpaceHtmlChars","curStringAtPosition","smartBackspace","stopNum","onLastStringBackspaced","onComplete","isTyping","isBlinking","cursorBlinking","add","speed","Math","round","random","shuffle","sort","className","fadeOutDelay","str","attr","setAttribute","isInput","value","contentType","innerHTML","textContent","addEventListener","e","showCursor","document","createElement","cursorChar","insertBefore","nextSibling"],"sources":["F:/Desktop/react/my/src/components/typed.js"],"sourcesContent":["import { initializer } from './initializer.js';\r\nimport { htmlParser } from './html-parser.js';\r\n\r\n/**\r\n * Welcome to Typed.js!\r\n * @param {string} elementId HTML element ID _OR_ HTML element\r\n * @param {object} options options object\r\n * @returns {object} a new Typed object\r\n */\r\nexport default class Typed {\r\n  constructor(elementId, options) {\r\n    // Initialize it up\r\n    initializer.load(this, options, elementId);\r\n    // All systems go!\r\n    this.begin();\r\n  }\r\n\r\n  /**\r\n   * Toggle start() and stop() of the Typed instance\r\n   * @public\r\n   */\r\n  toggle() {\r\n    this.pause.status ? this.start() : this.stop();\r\n  }\r\n\r\n  /**\r\n   * Stop typing / backspacing and enable cursor blinking\r\n   * @public\r\n   */\r\n  stop() {\r\n    if (this.typingComplete) return;\r\n    if (this.pause.status) return;\r\n    this.toggleBlinking(true);\r\n    this.pause.status = true;\r\n    this.options.onStop(this.arrayPos, this);\r\n  }\r\n\r\n  /**\r\n   * Start typing / backspacing after being stopped\r\n   * @public\r\n   */\r\n  start() {\r\n    if (this.typingComplete) return;\r\n    if (!this.pause.status) return;\r\n    this.pause.status = false;\r\n    if (this.pause.typewrite) {\r\n      this.typewrite(this.pause.curString, this.pause.curStrPos);\r\n    } else {\r\n      this.backspace(this.pause.curString, this.pause.curStrPos);\r\n    }\r\n    this.options.onStart(this.arrayPos, this);\r\n  }\r\n\r\n  /**\r\n   * Destroy this instance of Typed\r\n   * @public\r\n   */\r\n  destroy() {\r\n    this.reset(false);\r\n    this.options.onDestroy(this);\r\n  }\r\n\r\n  /**\r\n   * Reset Typed and optionally restarts\r\n   * @param {boolean} restart\r\n   * @public\r\n   */\r\n  reset(restart = true) {\r\n    clearInterval(this.timeout);\r\n    this.replaceText('');\r\n    if (this.cursor && this.cursor.parentNode) {\r\n      this.cursor.parentNode.removeChild(this.cursor);\r\n      this.cursor = null;\r\n    }\r\n    this.strPos = 0;\r\n    this.arrayPos = 0;\r\n    this.curLoop = 0;\r\n    if (restart) {\r\n      this.insertCursor();\r\n      this.options.onReset(this);\r\n      this.begin();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Begins the typing animation\r\n   * @private\r\n   */\r\n  begin() {\r\n    this.options.onBegin(this);\r\n    this.typingComplete = false;\r\n    this.shuffleStringsIfNeeded(this);\r\n    this.insertCursor();\r\n    if (this.bindInputFocusEvents) this.bindFocusEvents();\r\n    this.timeout = setTimeout(() => {\r\n      // If the strPos is 0, we're starting from the beginning of a string\r\n      // else, we're starting with a previous string that needs to be backspaced first\r\n      if (this.strPos === 0) {\r\n        this.typewrite(this.strings[this.sequence[this.arrayPos]], this.strPos);\r\n      } else {\r\n        this.backspace(this.strings[this.sequence[this.arrayPos]], this.strPos);\r\n      }\r\n    }, this.startDelay);\r\n  }\r\n\r\n  /**\r\n   * Called for each character typed\r\n   * @param {string} curString the current string in the strings array\r\n   * @param {number} curStrPos the current position in the curString\r\n   * @private\r\n   */\r\n  typewrite(curString, curStrPos) {\r\n    if (this.fadeOut && this.el.classList.contains(this.fadeOutClass)) {\r\n      this.el.classList.remove(this.fadeOutClass);\r\n      if (this.cursor) this.cursor.classList.remove(this.fadeOutClass);\r\n    }\r\n\r\n    const humanize = this.humanizer(this.typeSpeed);\r\n    let numChars = 1;\r\n\r\n    if (this.pause.status === true) {\r\n      this.setPauseStatus(curString, curStrPos, true);\r\n      return;\r\n    }\r\n\r\n    // contain typing function in a timeout humanize'd delay\r\n    this.timeout = setTimeout(() => {\r\n      // skip over any HTML chars\r\n      curStrPos = htmlParser.typeHtmlChars(curString, curStrPos, this);\r\n\r\n      let pauseTime = 0;\r\n      let substr = curString.substring(curStrPos);\r\n      // check for an escape character before a pause value\r\n      // format: \\^\\d+ .. eg: ^1000 .. should be able to print the ^ too using ^^\r\n      // single ^ are removed from string\r\n      if (substr.charAt(0) === '^') {\r\n        if (/^\\^\\d+/.test(substr)) {\r\n          let skip = 1; // skip at least 1\r\n          substr = /\\d+/.exec(substr)[0];\r\n          skip += substr.length;\r\n          pauseTime = parseInt(substr);\r\n          this.temporaryPause = true;\r\n          this.options.onTypingPaused(this.arrayPos, this);\r\n          // strip out the escape character and pause value so they're not printed\r\n          curString =\r\n            curString.substring(0, curStrPos) +\r\n            curString.substring(curStrPos + skip);\r\n          this.toggleBlinking(true);\r\n        }\r\n      }\r\n\r\n      // check for skip characters formatted as\r\n      // \"this is a `string to print NOW` ...\"\r\n      if (substr.charAt(0) === '`') {\r\n        while (curString.substring(curStrPos + numChars).charAt(0) !== '`') {\r\n          numChars++;\r\n          if (curStrPos + numChars > curString.length) break;\r\n        }\r\n        // strip out the escape characters and append all the string in between\r\n        const stringBeforeSkip = curString.substring(0, curStrPos);\r\n        const stringSkipped = curString.substring(\r\n          stringBeforeSkip.length + 1,\r\n          curStrPos + numChars\r\n        );\r\n        const stringAfterSkip = curString.substring(curStrPos + numChars + 1);\r\n        curString = stringBeforeSkip + stringSkipped + stringAfterSkip;\r\n        numChars--;\r\n      }\r\n\r\n      // timeout for any pause after a character\r\n      this.timeout = setTimeout(() => {\r\n        // Accounts for blinking while paused\r\n        this.toggleBlinking(false);\r\n\r\n        // We're done with this sentence!\r\n        if (curStrPos >= curString.length) {\r\n          this.doneTyping(curString, curStrPos);\r\n        } else {\r\n          this.keepTyping(curString, curStrPos, numChars);\r\n        }\r\n        // end of character pause\r\n        if (this.temporaryPause) {\r\n          this.temporaryPause = false;\r\n          this.options.onTypingResumed(this.arrayPos, this);\r\n        }\r\n      }, pauseTime);\r\n\r\n      // humanized value for typing\r\n    }, humanize);\r\n  }\r\n\r\n  /**\r\n   * Continue to the next string & begin typing\r\n   * @param {string} curString the current string in the strings array\r\n   * @param {number} curStrPos the current position in the curString\r\n   * @private\r\n   */\r\n  keepTyping(curString, curStrPos, numChars) {\r\n    // call before functions if applicable\r\n    if (curStrPos === 0) {\r\n      this.toggleBlinking(false);\r\n      this.options.preStringTyped(this.arrayPos, this);\r\n    }\r\n    // start typing each new char into existing string\r\n    // curString: arg, this.el.html: original text inside element\r\n    curStrPos += numChars;\r\n    const nextString = curString.substring(0, curStrPos);\r\n    this.replaceText(nextString);\r\n    // loop the function\r\n    this.typewrite(curString, curStrPos);\r\n  }\r\n\r\n  /**\r\n   * We're done typing the current string\r\n   * @param {string} curString the current string in the strings array\r\n   * @param {number} curStrPos the current position in the curString\r\n   * @private\r\n   */\r\n  doneTyping(curString, curStrPos) {\r\n    // fires callback function\r\n    this.options.onStringTyped(this.arrayPos, this);\r\n    this.toggleBlinking(true);\r\n    // is this the final string\r\n    if (this.arrayPos === this.strings.length - 1) {\r\n      // callback that occurs on the last typed string\r\n      this.complete();\r\n      // quit if we wont loop back\r\n      if (this.loop === false || this.curLoop === this.loopCount) {\r\n        return;\r\n      }\r\n    }\r\n    this.timeout = setTimeout(() => {\r\n      this.backspace(curString, curStrPos);\r\n    }, this.backDelay);\r\n  }\r\n\r\n  /**\r\n   * Backspaces 1 character at a time\r\n   * @param {string} curString the current string in the strings array\r\n   * @param {number} curStrPos the current position in the curString\r\n   * @private\r\n   */\r\n  backspace(curString, curStrPos) {\r\n    if (this.pause.status === true) {\r\n      this.setPauseStatus(curString, curStrPos, false);\r\n      return;\r\n    }\r\n    if (this.fadeOut) return this.initFadeOut();\r\n\r\n    this.toggleBlinking(false);\r\n    const humanize = this.humanizer(this.backSpeed);\r\n\r\n    this.timeout = setTimeout(() => {\r\n      curStrPos = htmlParser.backSpaceHtmlChars(curString, curStrPos, this);\r\n      // replace text with base text + typed characters\r\n      const curStringAtPosition = curString.substring(0, curStrPos);\r\n      this.replaceText(curStringAtPosition);\r\n\r\n      // if smartBack is enabled\r\n      if (this.smartBackspace) {\r\n        // the remaining part of the current string is equal of the same part of the new string\r\n        let nextString = this.strings[this.arrayPos + 1];\r\n        if (\r\n          nextString &&\r\n          curStringAtPosition === nextString.substring(0, curStrPos)\r\n        ) {\r\n          this.stopNum = curStrPos;\r\n        } else {\r\n          this.stopNum = 0;\r\n        }\r\n      }\r\n\r\n      // if the number (id of character in current string) is\r\n      // less than the stop number, keep going\r\n      if (curStrPos > this.stopNum) {\r\n        // subtract characters one by one\r\n        curStrPos--;\r\n        // loop the function\r\n        this.backspace(curString, curStrPos);\r\n      } else if (curStrPos <= this.stopNum) {\r\n        // if the stop number has been reached, increase\r\n        // array position to next string\r\n        this.arrayPos++;\r\n        // When looping, begin at the beginning after backspace complete\r\n        if (this.arrayPos === this.strings.length) {\r\n          this.arrayPos = 0;\r\n          this.options.onLastStringBackspaced();\r\n          this.shuffleStringsIfNeeded();\r\n          this.begin();\r\n        } else {\r\n          this.typewrite(this.strings[this.sequence[this.arrayPos]], curStrPos);\r\n        }\r\n      }\r\n      // humanized value for typing\r\n    }, humanize);\r\n  }\r\n\r\n  /**\r\n   * Full animation is complete\r\n   * @private\r\n   */\r\n  complete() {\r\n    this.options.onComplete(this);\r\n    if (this.loop) {\r\n      this.curLoop++;\r\n    } else {\r\n      this.typingComplete = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Has the typing been stopped\r\n   * @param {string} curString the current string in the strings array\r\n   * @param {number} curStrPos the current position in the curString\r\n   * @param {boolean} isTyping\r\n   * @private\r\n   */\r\n  setPauseStatus(curString, curStrPos, isTyping) {\r\n    this.pause.typewrite = isTyping;\r\n    this.pause.curString = curString;\r\n    this.pause.curStrPos = curStrPos;\r\n  }\r\n\r\n  /**\r\n   * Toggle the blinking cursor\r\n   * @param {boolean} isBlinking\r\n   * @private\r\n   */\r\n  toggleBlinking(isBlinking) {\r\n    if (!this.cursor) return;\r\n    // if in paused state, don't toggle blinking a 2nd time\r\n    if (this.pause.status) return;\r\n    if (this.cursorBlinking === isBlinking) return;\r\n    this.cursorBlinking = isBlinking;\r\n    if (isBlinking) {\r\n      this.cursor.classList.add('typed-cursor--blink');\r\n    } else {\r\n      this.cursor.classList.remove('typed-cursor--blink');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Speed in MS to type\r\n   * @param {number} speed\r\n   * @private\r\n   */\r\n  humanizer(speed) {\r\n    return Math.round((Math.random() * speed) / 2) + speed;\r\n  }\r\n\r\n  /**\r\n   * Shuffle the sequence of the strings array\r\n   * @private\r\n   */\r\n  shuffleStringsIfNeeded() {\r\n    if (!this.shuffle) return;\r\n    this.sequence = this.sequence.sort(() => Math.random() - 0.5);\r\n  }\r\n\r\n  /**\r\n   * Adds a CSS class to fade out current string\r\n   * @private\r\n   */\r\n  initFadeOut() {\r\n    this.el.className += ` ${this.fadeOutClass}`;\r\n    if (this.cursor) this.cursor.className += ` ${this.fadeOutClass}`;\r\n    return setTimeout(() => {\r\n      this.arrayPos++;\r\n      this.replaceText('');\r\n\r\n      // Resets current string if end of loop reached\r\n      if (this.strings.length > this.arrayPos) {\r\n        this.typewrite(this.strings[this.sequence[this.arrayPos]], 0);\r\n      } else {\r\n        this.typewrite(this.strings[0], 0);\r\n        this.arrayPos = 0;\r\n      }\r\n    }, this.fadeOutDelay);\r\n  }\r\n\r\n  /**\r\n   * Replaces current text in the HTML element\r\n   * depending on element type\r\n   * @param {string} str\r\n   * @private\r\n   */\r\n  replaceText(str) {\r\n    if (this.attr) {\r\n      this.el.setAttribute(this.attr, str);\r\n    } else {\r\n      if (this.isInput) {\r\n        this.el.value = str;\r\n      } else if (this.contentType === 'html') {\r\n        this.el.innerHTML = str;\r\n      } else {\r\n        this.el.textContent = str;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * If using input elements, bind focus in order to\r\n   * start and stop the animation\r\n   * @private\r\n   */\r\n  bindFocusEvents() {\r\n    if (!this.isInput) return;\r\n    this.el.addEventListener('focus', (e) => {\r\n      this.stop();\r\n    });\r\n    this.el.addEventListener('blur', (e) => {\r\n      if (this.el.value && this.el.value.length !== 0) {\r\n        return;\r\n      }\r\n      this.start();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * On init, insert the cursor element\r\n   * @private\r\n   */\r\n  insertCursor() {\r\n    if (!this.showCursor) return;\r\n    if (this.cursor) return;\r\n    this.cursor = document.createElement('span');\r\n    this.cursor.className = 'typed-cursor';\r\n    this.cursor.setAttribute('aria-hidden', true);\r\n    this.cursor.innerHTML = this.cursorChar;\r\n    this.el.parentNode &&\r\n      this.el.parentNode.insertBefore(this.cursor, this.el.nextSibling);\r\n  }\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}